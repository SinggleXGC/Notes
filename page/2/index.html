<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/notes/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/notes/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/notes/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/notes/images/logo.svg" color="#222">

<link rel="stylesheet" href="/notes/css/main.css">


<link rel="stylesheet" href="/notes/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"singglexgc.github.io","root":"/notes/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Notes">
<meta property="og:url" content="https://singglexgc.github.io/notes/page/2/index.html">
<meta property="og:site_name" content="Notes">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Sinngle">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://singglexgc.github.io/notes/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Notes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/notes/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Notes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/notes/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/notes/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://singglexgc.github.io/notes/2021/07/05/JavaSE/methodhandle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/notes/images/avatar.gif">
      <meta itemprop="name" content="Sinngle">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/notes/2021/07/05/JavaSE/methodhandle/" class="post-title-link" itemprop="url">MethodHandle</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-05 20:59:51" itemprop="dateCreated datePublished" datetime="2021-07-05T20:59:51+08:00">2021-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-10 18:43:11" itemprop="dateModified" datetime="2021-07-10T18:43:11+08:00">2021-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/notes/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="JDK何时引入？"><a href="#JDK何时引入？" class="headerlink" title="JDK何时引入？"></a>JDK何时引入？</h2><p>MethodHandle是JDK7引入的API，该包提供了一种新的动态调用方法的 机制。</p>
<h2 id="什么是MethodHandle？"><a href="#什么是MethodHandle？" class="headerlink" title="什么是MethodHandle？"></a>什么是MethodHandle？</h2><p>MethodHandle是对底层方法、构造函数、字段或类似低级操作的类型化，直接可执行的引用，具有参数或返回值的可选转换。</p>
<p>简单点来说，MethodHandle就是一个方法句柄，能够通过这个方法句柄调用对应方法。</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>先演示String类的replace方法的使用，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String handleStr = str.replace(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">        System.out.println(handleStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cbc</span><br></pre></td></tr></table></figure>

<p>在这里，我们演示使用MethodHandle方式来调用String类的replace方法，将abc字符串内的所有a字符替换成c字符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandleTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 借助MethodHandles创建 方法查找 对象</span></span><br><span class="line">        MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">        <span class="comment">// 创建 MethodType 方法类型 对象,该对象代表方法的返回类型和参数类型</span></span><br><span class="line">        <span class="comment">// 第一个参数是返回类型，后面的参数就是方法的参数类型</span></span><br><span class="line">        MethodType methodType = </span><br><span class="line">            MethodType.methodType(String.class, <span class="keyword">char</span>.class, <span class="keyword">char</span>.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过MethodHandles.Lookup对象提供的方法查找方法句柄</span></span><br><span class="line">            <span class="comment">// 第一个参数是在String类中查找</span></span><br><span class="line">            <span class="comment">// 第二个参数表示要查找replace方法</span></span><br><span class="line">            MethodHandle methodHandle = </span><br><span class="line">                lookup.findVirtual(String.class, <span class="string">&quot;replace&quot;</span>, methodType);</span><br><span class="line">            <span class="comment">// 通过方法句柄调用对应方法，并获得方法返回值</span></span><br><span class="line">            String handleStr = (String) methodHandle.invoke(<span class="string">&quot;abc&quot;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">            System.out.println(handleStr);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cbc</span><br></pre></td></tr></table></figure>



<h2 id="使用步骤总结"><a href="#使用步骤总结" class="headerlink" title="使用步骤总结"></a>使用步骤总结</h2><p>总结一下使用MethodHandle的步骤：</p>
<ol>
<li>创建查找(MethodHandles.Lookup)</li>
<li>创建方法类型(MethodType)</li>
<li>查找方法句柄(MethodHandle)</li>
<li>调用方法句柄</li>
</ol>
<h3 id="创建查找"><a href="#创建查找" class="headerlink" title="创建查找"></a>创建查找</h3><p>通过MethodHandles提供的API，我们可以创建具有不同访问权限的查找对象。</p>
<p>创建提供对公共方法的访问的查找：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();</span><br></pre></td></tr></table></figure>

<p>创建提供对任何访问权限的方法的查找：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br></pre></td></tr></table></figure>



<h3 id="创建方法类型"><a href="#创建方法类型" class="headerlink" title="创建方法类型"></a>创建方法类型</h3><p>一个方法类型(MethodType)由返回类型和适当数量的参数类型组成。</p>
<p>使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MethodType methodType =</span><br><span class="line">    MethodType.methodType(String.class, <span class="keyword">char</span>.class, <span class="keyword">char</span>.class);</span><br></pre></td></tr></table></figure>

<p>上面代码将String类型指定为返回类型，两个char类型指定为参数类型。</p>
<p>如果方法无返回值，或者无参数。那么在<code>MethodType.methodType()</code>方法传入对应参数为<code>void.class</code></p>
<h3 id="查找方法句柄"><a href="#查找方法句柄" class="headerlink" title="查找方法句柄"></a>查找方法句柄</h3><p>在创建完查找对象和方法类型对象之后，我们可以将方法类型对象传入查找对象的对应方法中，从而查找并获取对应的方法句柄。</p>
<ol>
<li><p>实例方法</p>
<p>使用<code>MethodHandle.Lookup</code>对象的<code>findVirtual()</code>方法，可以为对象方法创建MethodHandle对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MethodType methodType = </span><br><span class="line">    MethodType.methodType(String.class, <span class="keyword">char</span>.class, <span class="keyword">char</span>.class);</span><br><span class="line">MethodHandle methodHandle = lookup.findVirtual(String.class, <span class="string">&quot;replace&quot;</span>, methodType);</span><br></pre></td></tr></table></figure></li>
<li><p>静态方法</p>
<p>使用<code>findStatic()</code>方法可以查找静态方法的MethodHandle对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MethodType methodType = </span><br><span class="line">    MethodType.methodType(List.class, Object[].class);</span><br><span class="line">MethodHandle methodHandle = lookup.findStatic(Arrays.class, <span class="string">&quot;asList&quot;</span>, methodType);</span><br></pre></td></tr></table></figure></li>
<li><p>构造函数</p>
<p>使用<code>findConstructor()</code>方法来访问构造函数。</p>
<p>下面代码创建一个Integer类的构造函数的方法句柄，接收一个String为参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MethodType mt = MethodType.methodType(<span class="keyword">void</span>.class, String.class);</span><br><span class="line">MethodHandle methodHandle = lookup.findConstructor(Integer.class, mt);</span><br></pre></td></tr></table></figure></li>
<li><p>字段</p>
<p>利用MethodHandle，还可以访问字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String id;</span><br><span class="line">    String title;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String id, String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MethodHandle methodHandle = lookup.findGetter(Book.class, <span class="string">&quot;title&quot;</span>, String.class);</span><br><span class="line">String title = (String) methodHandle.invoke(<span class="keyword">new</span> Book(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;我与地坛&quot;</span>));</span><br></pre></td></tr></table></figure></li>
<li><p>私有方法</p>
<p>利用<code>java.lang.reflect</code>的API，我们可以为私有方法创建方法句柄。</p>
<p>为上面的Book类添加一个私有方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">formatBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id + <span class="string">&quot;&gt;&quot;</span> + title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Method formatBookMethod = Book.class.getDeclaredMethod(<span class="string">&quot;formatBook&quot;</span>);</span><br><span class="line">formatBookMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">MethodHandle methodHandle = lookup.unreflect(formatBookMethod);</span><br><span class="line">String str = (String) methodHandle.invoke(<span class="keyword">new</span> Book(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;我与地坛&quot;</span>));</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="调用方法句柄"><a href="#调用方法句柄" class="headerlink" title="调用方法句柄"></a>调用方法句柄</h3><p>创建了方法句柄，即拥有了对应方法的引用。我们通过方法句柄就可以调用对应的方法。</p>
<p>MethodHandle提供了三种执行方法句柄的方法：<code>invoke()</code>、<code>invokeWithArguments()</code>、<code>invokeExact()</code>。</p>
<ol>
<li><p><code>invokeExact()</code>方法</p>
<p>invokeExact()方法在调用时要求严格的类型匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MethodHandle methodHandle = lookup.findVirtual(String.class, <span class="string">&quot;replace&quot;</span>, methodType);</span><br><span class="line">Object handleStr = methodHandle.invokeExact(<span class="string">&quot;abc&quot;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">System.out.println(handleStr);</span><br></pre></td></tr></table></figure>

<p>上述代码执行后会报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.invoke.WrongMethodTypeException: expected (String,<span class="keyword">char</span>,<span class="keyword">char</span>)<span class="function">String but <span class="title">found</span> <span class="params">(String,<span class="keyword">char</span>,<span class="keyword">char</span>)</span>Object</span></span><br><span class="line"><span class="function">	at java.lang.invoke.Invokers.<span class="title">newWrongMethodTypeException</span><span class="params">(Invokers.java:<span class="number">298</span>)</span></span></span><br><span class="line"><span class="function">	at java.lang.invoke.Invokers.<span class="title">checkExactType</span><span class="params">(Invokers.java:<span class="number">309</span>)</span></span></span><br><span class="line"><span class="function">	at com.xgc.InvokeMethodHandle.<span class="title">main</span><span class="params">(InvokeMethodHandle.java:<span class="number">14</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>这是因为，不将<code>methodHandle.invokeExact(&quot;abc&quot;, &#39;a&#39;, &#39;c&#39;)</code>强制转型成String的话，在调用的时候该方法会以为返回值时Object类型，而不是String类型，所以会抛出异常。</p>
</li>
<li><p><code>invoke()</code>方法</p>
<p>跟<code>invokeExact()</code>方法不同，invoke方法允许更加松散的调用方式。它会尝试在调用的时候进行返回值和参数类型转换工作。</p>
<p>转换工作是通过MethodHandle类的asType()方法来完成的。asType()方法是将当前方法句柄适配到新的HandleType上面，并产生一个新的方法句柄。</p>
</li>
<li><p><code>invokeWithArguments()</code>方法</p>
<p><code>invokeWithArguments()</code>方法除了对参数和返回类型进行强制转换、装箱和拆箱外，它还允许传入一个包含了多个参数的数组或List对象。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://singglexgc.github.io/notes/2021/06/24/MyBatis/mybatis%E6%89%A7%E8%A1%8Csql%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/notes/images/avatar.gif">
      <meta itemprop="name" content="Sinngle">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/notes/2021/06/24/MyBatis/mybatis%E6%89%A7%E8%A1%8Csql%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">MyBatis执行SQL源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-24 00:52:26" itemprop="dateCreated datePublished" datetime="2021-06-24T00:52:26+08:00">2021-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-05 20:15:30" itemprop="dateModified" datetime="2021-07-05T20:15:30+08:00">2021-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/notes/categories/MyBatis/" itemprop="url" rel="index"><span itemprop="name">MyBatis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="原始MyBatis使用步骤"><a href="#原始MyBatis使用步骤" class="headerlink" title="原始MyBatis使用步骤"></a>原始MyBatis使用步骤</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">List&lt;Student&gt; students = studentMapper.selectAll();</span><br></pre></td></tr></table></figure>



<h2 id="SqlSession的构建过程"><a href="#SqlSession的构建过程" class="headerlink" title="SqlSession的构建过程"></a>SqlSession的构建过程</h2><p>SqlSession的构建过程可以分为</p>
<ul>
<li>Configuration实例的构建过程</li>
<li>SqlSessionFactory实例的构建过程</li>
<li>SqlSession实例化的过程</li>
</ul>
<p>SqlSession的构建过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure>

<p>接下来深入源码分析。</p>
<h3 id="Configuration和SqlSessionFactory构建过程"><a href="#Configuration和SqlSessionFactory构建过程" class="headerlink" title="Configuration和SqlSessionFactory构建过程"></a>Configuration和SqlSessionFactory构建过程</h3><p><code>new SqlSessionFactoryBuilder().build(inputStream)</code>的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> build(inputStream, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputSteam inputStream, String environment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> build(inputStream, environment, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> build(inputStream, <span class="keyword">null</span>, properties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">        <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>parser.parse()</code>定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到XMLConfigBuilder对象的parse()方法会进行解析工作，并最后返回一个构建成功的Configuration对象。</p>
<p>Configuration具体的构建过程不进行解释，主要是对MyBatis的配置文件及注解进行解析。我们只需要知道Configuration对象是通过XMLConfigBuilder对象的parse方法完成解析。</p>
<p>这样Configuration对象的构建过程就完成了。</p>
<p>接下来讲述SqlSessionFactory对象的构建过程：</p>
<p><code>build(parser.parse())</code>的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是SqlSessionFactory对象也构建好了。</p>
<h3 id="SqlSession实例化的过程"><a href="#SqlSession实例化的过程" class="headerlink" title="SqlSession实例化的过程"></a>SqlSession实例化的过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure>

<p>其中<code>sqlSessionFactory.openSession()</code>的定义如下：</p>
<p>(注意此时sqlSessionFactory对象的类型为DefaultSqlSessionFactory)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  openSessionFromDataSource的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">        <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">        <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就返回了一个DefaultSqlSession对象，完成了SqlSession实例化的过程。</p>
<h2 id="SqlSession执行Mapper的过程"><a href="#SqlSession执行Mapper的过程" class="headerlink" title="SqlSession执行Mapper的过程"></a>SqlSession执行Mapper的过程</h2><p>SqlSession执行Mapper的过程可以分成四部分：</p>
<ol>
<li>Mapper接口的注册过程</li>
<li>MappedStatement对象的注册过程</li>
<li>Mapper方法的调用过程</li>
<li>SqlSession执行Mapper的过程</li>
</ol>
<p>SqlSession执行Mapper的使用代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">List&lt;Student&gt; students = studentMapper.selectAll();</span><br></pre></td></tr></table></figure>

<p>我们知道StudentMapper是一个Mapper接口，而接口是不能实例化的。所以<code>sqlSession.getMapper()</code>方法返回的一定是一个对象。</p>
<p>MyBatis中，<code>sqlSession.getMapper()</code>方法通过JDK动态代理来创建代理对象。</p>
<p><code>sqlSession.getMapper()</code>方法定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> configuration.getMapper(type, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>configuration.getMapper()</code>方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mapperRegistry.getMapper()</code>方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mapperProxyFactory.newInstance()</code>定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MapperProxyFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>newInstance(mapperProxy)</code>的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MapperProxyFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里，我们就明白了。</p>
<p>MapperProxyFactory是对<code>Proxy.newProxyInstance()</code>方法的封装。</p>
<p>MapperProxy是对InvocationHandler接口的实现。</p>
<h3 id="Mapper接口的注册过程"><a href="#Mapper接口的注册过程" class="headerlink" title="Mapper接口的注册过程"></a>Mapper接口的注册过程</h3><p>在上面的源码分析中，我们知道<code>sqlSession.getMapper()</code>方法最终是通过<code>mapperRegistry.getMapper()</code>方法来实现的。</p>
<p>既然存在getMapper()方法也就意味着存在addMapper()方法。</p>
<p>于是，我们可以在<code>MapperRegistry</code>类中找到<code>addMapper()</code>方法的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapperRegistry</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasMapper(type)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is already known to the MapperRegistry.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory&lt;&gt;(type));</span><br><span class="line">            <span class="comment">// It&#x27;s important that the type is added before the parser is run</span></span><br><span class="line">            <span class="comment">// otherwise the binding may automatically be attempted by the</span></span><br><span class="line">            <span class="comment">// mapper parser. If the type is already known, it won&#x27;t try.</span></span><br><span class="line">            MapperAnnotationBuilder parser = <span class="keyword">new</span> MapperAnnotationBuilder(config, type);</span><br><span class="line">            parser.parse();</span><br><span class="line">            loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">                knownMappers.remove(type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在MapperRegistry中定义的<code>addMapper(Class&lt;T&gt; type)</code>方法中，在<code>knownMappers</code>属性中存放<code>MapperProxyFactory</code>对象。</p>
<p>下面是<code>knownMappers</code>属性的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>那么<code>MapperRegistry.addMapper(Class&lt;T&gt; type)</code>方法是什么时候被调用的呢？</p>
<p>往回追溯：</p>
<p>我们会发现只有两处调用了这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MapperRegistry</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMappers</span><span class="params">(String packageName, Class&lt;?&gt; superType)</span> </span>&#123;</span><br><span class="line">    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = <span class="keyword">new</span> ResolverUtil&lt;&gt;();</span><br><span class="line">    resolverUtil.find(<span class="keyword">new</span> ResolverUtil.IsA(superType), packageName);</span><br><span class="line">    Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; mapperSet = resolverUtil.getClasses();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; mapperClass : mapperSet) &#123;</span><br><span class="line">        addMapper(mapperClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Configuration</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    mapperRegistry.addMapper(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以<code>Configuration.addMapper(Class&lt;T&gt; type)</code>方法继续追溯：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XMLConfigBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>最后可以看到是<code>XMLConfigBuilder</code>对象的<code>mapperElement(XNode parent)</code>方法调用了<code>Configuration.addMapper(Class&lt;T&gt; type)</code>方法来完成Mapper接口的注册。</p>
<p>总结一下：</p>
<p>MyBatis在启动的时候，就会对Mapper配置文件进行解析，将Mapper标签的信息解析出来之后，就会使用<code>addMapper</code>方法将Mapper接口与对应的MapperProxyFactory对象注册到<code>knownMappers</code>中。</p>
<h3 id="MappedStatement对象的注册过程"><a href="#MappedStatement对象的注册过程" class="headerlink" title="MappedStatement对象的注册过程"></a>MappedStatement对象的注册过程</h3><p>MappedStatement对象其实就是对MyBatis配置文件中单个<code>select|update|delete|insert</code>标签，或<code>@Select</code>、<code>@Update</code>等注解信息的封装。</p>
<p>Configuration对象描述了MyBatis配置信息，其中也包括了MappedStatement对象。</p>
<p>沿着这个思路，我们从Configuration类开始追踪MappedStatement对象的注册过程。</p>
<p>于是我们在Configuration类中找到了mappedStatments属性，它用来存储MappedStatment对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Configuration</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, MappedStatement&gt; mappedStatements = </span><br><span class="line">    <span class="keyword">new</span> StrictMap&lt;MappedStatement&gt;(<span class="string">&quot;Mapped Statements collection&quot;</span>)</span><br><span class="line">    .conflictMessageProducer(</span><br><span class="line">        (savedValue, targetValue)</span><br><span class="line">        -&gt;</span><br><span class="line">        <span class="string">&quot;. please check &quot;</span> + savedValue.getResource() + <span class="string">&quot; and &quot;</span> + </span><br><span class="line">    	targetValue.getResource()</span><br><span class="line">	);</span><br></pre></td></tr></table></figure>

<p>Configuration提供了<code>addMappedStatement</code>方法来注册MappedStatment对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMappedStatement</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">    mappedStatements.put(ms.getId(), ms);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，我们就知道了注册MappedStatement对象的方法。</p>
<p>那么是哪里调用了<code>Configuration</code>对象的<code>addMappedStatement</code>方法，是哪里创建了MappedStatement对象？</p>
<p>我们知道MappedStatement对象是对SQL配置信息的封装，所以可以预想到MappedStatement对象是在MyBatis配置文件解析的时候生成的。</p>
<p>那么从XMLConfigBuilder对象开始进行源码追踪。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XMLConfigBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Each XMLConfigBuilder can only be used once.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    parsed = <span class="keyword">true</span>;</span><br><span class="line">    parseConfiguration(parser.evalNode(<span class="string">&quot;/configuration&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>parseConfiguration方法的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XMLConfigBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// issue #117 read properties first</span></span><br><span class="line">        propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>));</span><br><span class="line">        Properties settings = settingsAsProperties(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line">        loadCustomVfs(settings);</span><br><span class="line">        loadCustomLogImpl(settings);</span><br><span class="line">        typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));</span><br><span class="line">        pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line">        objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));</span><br><span class="line">        objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));</span><br><span class="line">        reflectorFactoryElement(root.evalNode(<span class="string">&quot;reflectorFactory&quot;</span>));</span><br><span class="line">        settingsElement(settings);</span><br><span class="line">        <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">        environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>));</span><br><span class="line">        databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));</span><br><span class="line">        typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));</span><br><span class="line">        mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要了解MappedStatement对象的创建过程，就要了解mappers标签的解析过程。</p>
<p>Configuration对象的parseConfiguration方法中，存在<code>mapperElement(root.evalNode(&quot;mappers&quot;));</code>这行代码用来解析mappers标签。</p>
<p>接下来查看mapperElement方法的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XMLConfigBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//循环获取子标签</span></span><br><span class="line">        <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">            <span class="comment">//如果子标签是 package</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">                String mapperPackage = child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                configuration.addMappers(mapperPackage);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                String resource = child.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">                String url = child.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">                String mapperClass = child.getStringAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ErrorContext.instance().resource(resource);</span><br><span class="line">                    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">                    XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">                    mapperParser.parse();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ErrorContext.instance().resource(url);</span><br><span class="line">                    InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">                    XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">                    mapperParser.parse();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">                    configuration.addMapper(mapperInterface);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>在了解Configuration对象的mapperElement()方法做了什么之前，我们先来看看mappers标签配置mapper信息的几种方式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过resource属性指定Mapper文件的classpath路径 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/xgc/mapper/StudentMapper.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过url属性指定Mapper文件网络路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file://com/xgc/StudentMapper.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过class属性指定Mapper接口的全限定名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.xgc.mapper.StudentMapper&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过package标签的name属性指定Mapper接口所在的包名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.xgc.mapper&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着，我们回看Configuration对象的mapperElement()方法。我们就会发现，其实就是遍历mappers标签下的子标签，并且根据上述不同的mapper配置方式，采用对应的解析方式。</p>
<p>这里以通过mapper的resource属性配置mapper信息为例，那么mapperElement方法中解析这种情况的对应代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String resource = child.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">......</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(</span><br><span class="line">    inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">mapperParser.parse();</span><br></pre></td></tr></table></figure>

<p>可以看到对mapper信息的解析工作实际是通过XMLMapperBuilder对象的parse方法来完成的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XMLMapperBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">        <span class="comment">//调用XPathParser的evalNode()方法获取根节点对应的XNode对象</span></span><br><span class="line">        configurationElement(parser.evalNode(<span class="string">&quot;/mapper&quot;</span>));</span><br><span class="line">        <span class="comment">//将资源路径添加到Configuration对象中</span></span><br><span class="line">        configuration.addLoadedResource(resource);</span><br><span class="line">        bindMapperForNamespace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续解析之前解析出现异常的ResultMap对象</span></span><br><span class="line">    parsePendingResultMaps();</span><br><span class="line">    <span class="comment">//继续解析之前解析出现异常的CacheRef对象</span></span><br><span class="line">    parsePendingCacheRefs();</span><br><span class="line">    <span class="comment">//继续解析之前解析出现异常的select|update|delete|insert标签</span></span><br><span class="line">    parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，首先使用XPathParser使用evalNode方法获取根节点对应的XNode对象，然后作为参数传给configurationElement方法来对Mapper配置内容做进一步的解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取命名空间</span></span><br><span class="line">        String namespace = context.getStringAttribute(<span class="string">&quot;namespace&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (namespace == <span class="keyword">null</span> || namespace.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Mapper&#x27;s namespace cannot be empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置当前正在解析的Mapper配置的命名空间</span></span><br><span class="line">        builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">        <span class="comment">//解析&lt;cache-ref&gt;标签</span></span><br><span class="line">        cacheRefElement(context.evalNode(<span class="string">&quot;cache-ref&quot;</span>));</span><br><span class="line">        <span class="comment">//解析&lt;cache&gt;标签</span></span><br><span class="line">        cacheElement(context.evalNode(<span class="string">&quot;cache&quot;</span>));</span><br><span class="line">        <span class="comment">//解析所有的&lt;parameterMap&gt;标签</span></span><br><span class="line">        parameterMapElement(context.evalNodes(<span class="string">&quot;/mapper/parameterMap&quot;</span>));</span><br><span class="line">        <span class="comment">//解析所有的&lt;resultMap&gt;标签</span></span><br><span class="line">        resultMapElements(context.evalNodes(<span class="string">&quot;/mapper/resultMap&quot;</span>));</span><br><span class="line">        <span class="comment">//解析所有的&lt;sql&gt;标签</span></span><br><span class="line">        sqlElement(context.evalNodes(<span class="string">&quot;/mapper/sql&quot;</span>));</span><br><span class="line">        <span class="comment">//解析所有的&lt;select|insert|update|delete&gt;标签</span></span><br><span class="line">        buildStatementFromContext(context.evalNodes(<span class="string">&quot;select|insert|update|delete&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error parsing Mapper XML. The XML location is &#x27;&quot;</span> + resource + <span class="string">&quot;&#x27;. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面代码所示，configurationElement()方法对Mapper SQL配置的所有标签进行解析。这里，重点关注<code>&lt;select|insert|update|delete&gt;</code>标签的解析。在获取这些标签对应的XNode对象之后，作为参数传给了<code>XMLMapperBuilder</code>类的<code>buildStatmentFromContext()</code>方法。<code>buildStatmentFromContext()</code>方法的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (configuration.getDatabaseId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        buildStatementFromContext(list, configuration.getDatabaseId());</span><br><span class="line">    &#125;</span><br><span class="line">    buildStatementFromContext(list, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode context : list) &#123;</span><br><span class="line">        <span class="comment">//通过XMLStatmentBuilder对象对&lt;select|insert|update|delete&gt;标签进行解析</span></span><br><span class="line">        <span class="keyword">final</span> XMLStatementBuilder statementParser = <span class="keyword">new</span> XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用parseStatementNode()方法进行解析</span></span><br><span class="line">            statementParser.parseStatementNode();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">            configuration.addIncompleteStatement(statementParser);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;select|insert|update|delete&gt;</code>标签的解析是通过XMLStatementBuilder对象来完成的。通过循环遍历所有的XNode对象，然后为每个代表<code>&lt;select|insert|update|delete&gt;</code>标签对应的XNode对象创建一个XMLStatementBuilder对象，接着调用XMLStatementBuilder对象的parseStatementNode()方法进行解析。</p>
<p>下面是<code>parseStatmentNode()</code>方法的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XMLStatmentBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseStatementNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String id = context.getStringAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    String databaseId = context.getStringAttribute(<span class="string">&quot;databaseId&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="keyword">this</span>.requiredDatabaseId)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String nodeName = context.getNode().getNodeName();</span><br><span class="line">    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">    <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">    <span class="keyword">boolean</span> flushCache = context.getBooleanAttribute(<span class="string">&quot;flushCache&quot;</span>, !isSelect);</span><br><span class="line">    <span class="keyword">boolean</span> useCache = context.getBooleanAttribute(<span class="string">&quot;useCache&quot;</span>, isSelect);</span><br><span class="line">    <span class="keyword">boolean</span> resultOrdered = context.getBooleanAttribute(<span class="string">&quot;resultOrdered&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Include Fragments before parsing</span></span><br><span class="line">    <span class="comment">// 将&lt;include&gt;标签内容替换成&lt;sql&gt;标签定义的SQL片段</span></span><br><span class="line">    XMLIncludeTransformer includeParser = <span class="keyword">new</span> XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line">    includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">    String parameterType = context.getStringAttribute(<span class="string">&quot;parameterType&quot;</span>);</span><br><span class="line">    Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line"></span><br><span class="line">    String lang = context.getStringAttribute(<span class="string">&quot;lang&quot;</span>);</span><br><span class="line">    LanguageDriver langDriver = getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse selectKey after includes and remove them.</span></span><br><span class="line">    processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed)</span></span><br><span class="line">    KeyGenerator keyGenerator;</span><br><span class="line">    String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">        keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        keyGenerator = context.getBooleanAttribute(<span class="string">&quot;useGeneratedKeys&quot;</span>,</span><br><span class="line">                                                   configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">            ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line">    <span class="comment">//Statement默认类型为PREPARED</span></span><br><span class="line">    StatementType statementType = StatementType.valueOf(context.getStringAttribute(<span class="string">&quot;statementType&quot;</span>, StatementType.PREPARED.toString()));</span><br><span class="line">    <span class="comment">//解析&lt;select|insert|delete|update&gt;标签属性</span></span><br><span class="line">    Integer fetchSize = context.getIntAttribute(<span class="string">&quot;fetchSize&quot;</span>);</span><br><span class="line">    Integer timeout = context.getIntAttribute(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">    String parameterMap = context.getStringAttribute(<span class="string">&quot;parameterMap&quot;</span>);</span><br><span class="line">    String resultType = context.getStringAttribute(<span class="string">&quot;resultType&quot;</span>);</span><br><span class="line">    Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">    String resultMap = context.getStringAttribute(<span class="string">&quot;resultMap&quot;</span>);</span><br><span class="line">    String resultSetType = context.getStringAttribute(<span class="string">&quot;resultSetType&quot;</span>);</span><br><span class="line">    ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);</span><br><span class="line">    <span class="keyword">if</span> (resultSetTypeEnum == <span class="keyword">null</span>) &#123;</span><br><span class="line">        resultSetTypeEnum = configuration.getDefaultResultSetType();</span><br><span class="line">    &#125;</span><br><span class="line">    String keyProperty = context.getStringAttribute(<span class="string">&quot;keyProperty&quot;</span>);</span><br><span class="line">    String keyColumn = context.getStringAttribute(<span class="string">&quot;keyColumn&quot;</span>);</span><br><span class="line">    String resultSets = context.getStringAttribute(<span class="string">&quot;resultSets&quot;</span>);</span><br><span class="line"></span><br><span class="line">    builderAssistant.addMappedStatement(</span><br><span class="line">        id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap,              			resultTypeClass, resultSetTypeEnum, flushCache, useCache, resultOrdered, 			    keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>XMLStatmentBuilder</code>类的<code>parseStatmentNode()</code>方法主要做了如下几件事：</p>
<ol>
<li>将<code>&lt;include&gt;</code>标签引用的SQL片段替换成对应的<code>&lt;sql&gt;</code>标签的内容</li>
<li>获取lang属性指定的LanguageDriver，通过LanguageDriver创建SqlSource。MyBatis中的SqlSource代表的是一个SQL资源。</li>
<li>获取KeyGenerator对象。KeyGenerator的不同实例代表了不同的生成策略。</li>
<li>获取<code>&lt;select|insert|delete|update&gt;</code>标签的所有属性</li>
<li>所有解析工作完成之后，使用MapperBuilderAssistant对象的addMappedStatment()方法创建MappedStatment对象。</li>
</ol>
<p>下面是MapperBuilderAssistant对象的addMappedStatment()方法的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MappedStatement <span class="title">addMappedStatement</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    String id,</span></span></span><br><span class="line"><span class="params"><span class="function">    SqlSource sqlSource,</span></span></span><br><span class="line"><span class="params"><span class="function">    StatementType statementType,</span></span></span><br><span class="line"><span class="params"><span class="function">    SqlCommandType sqlCommandType,</span></span></span><br><span class="line"><span class="params"><span class="function">    Integer fetchSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    Integer timeout,</span></span></span><br><span class="line"><span class="params"><span class="function">    String parameterMap,</span></span></span><br><span class="line"><span class="params"><span class="function">    Class&lt;?&gt; parameterType,</span></span></span><br><span class="line"><span class="params"><span class="function">    String resultMap,</span></span></span><br><span class="line"><span class="params"><span class="function">    Class&lt;?&gt; resultType,</span></span></span><br><span class="line"><span class="params"><span class="function">    ResultSetType resultSetType,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">boolean</span> flushCache,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">boolean</span> useCache,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">boolean</span> resultOrdered,</span></span></span><br><span class="line"><span class="params"><span class="function">    KeyGenerator keyGenerator,</span></span></span><br><span class="line"><span class="params"><span class="function">    String keyProperty,</span></span></span><br><span class="line"><span class="params"><span class="function">    String keyColumn,</span></span></span><br><span class="line"><span class="params"><span class="function">    String databaseId,</span></span></span><br><span class="line"><span class="params"><span class="function">    LanguageDriver lang,</span></span></span><br><span class="line"><span class="params"><span class="function">    String resultSets)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unresolvedCacheRef) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">&quot;Cache-ref not yet resolved&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id = applyCurrentNamespace(id, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line"></span><br><span class="line">    MappedStatement.Builder statementBuilder = <span class="keyword">new</span> MappedStatement.Builder(configuration, id, sqlSource, sqlCommandType)</span><br><span class="line">        .resource(resource)</span><br><span class="line">        .fetchSize(fetchSize)</span><br><span class="line">        .timeout(timeout)</span><br><span class="line">        .statementType(statementType)</span><br><span class="line">        .keyGenerator(keyGenerator)</span><br><span class="line">        .keyProperty(keyProperty)</span><br><span class="line">        .keyColumn(keyColumn)</span><br><span class="line">        .databaseId(databaseId)</span><br><span class="line">        .lang(lang)</span><br><span class="line">        .resultOrdered(resultOrdered)</span><br><span class="line">        .resultSets(resultSets)</span><br><span class="line">        .resultMaps(getStatementResultMaps(resultMap, resultType, id))</span><br><span class="line">        .resultSetType(resultSetType)</span><br><span class="line">        .flushCacheRequired(valueOrDefault(flushCache, !isSelect))</span><br><span class="line">        .useCache(valueOrDefault(useCache, isSelect))</span><br><span class="line">        .cache(currentCache);</span><br><span class="line"></span><br><span class="line">    ParameterMap statementParameterMap = getStatementParameterMap(parameterMap, parameterType, id);</span><br><span class="line">    <span class="keyword">if</span> (statementParameterMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        statementBuilder.parameterMap(statementParameterMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MappedStatement statement = statementBuilder.build();</span><br><span class="line">    configuration.addMappedStatement(statement);</span><br><span class="line">    <span class="keyword">return</span> statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MapperStatementAssistant</code>的<code>addMappedStatment()</code>方法创建了<code>MappedStatement</code>对象之后，通过<code>Configuration</code>对象的<code>addMappedStatement()</code>方法注册到Configuration对象中。</p>
<p>注：MyBatis中的MapperStatementAssistant是一个辅助工具类，用于构建Mapper相关的对象，例如Cache、ParameterMap、ResultMap等。</p>
<h3 id="Mapper方法的调用过程"><a href="#Mapper方法的调用过程" class="headerlink" title="Mapper方法的调用过程"></a>Mapper方法的调用过程</h3><p>MyBatis调用Mapper方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">List&lt;Student&gt; students = studentMapper.selectAll();</span><br></pre></td></tr></table></figure>

<p>我们知道<code>sqlSession.getMapper()</code>方法返回的是一个代理对象。MyBatis中通过MapperProxy类实现了<code>InvocationHandler</code>接口。这样，当代理对象执行方法的时候，调用的是MapperProxy类中实现的invoke方法。</p>
<p>MapperProxy类实现的invoke方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapperProxy</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从Object类继承的方法不做处理</span></span><br><span class="line">        <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cachedInvoker(method).invoke(proxy, method, args, sqlSession);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码我们可以看到，MapperProxy在invoke方法中，对于从Object类继承的方法不做处理，其他的方法通过<code>cachedInvoker(method).invoke(proxy, method, args, sqlSession)</code>来进行处理。</p>
<p><code>cachedInvoker()</code>方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapperProxy</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> MapperMethodInvoker <span class="title">cachedInvoker</span><span class="params">(Method method)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// A workaround for https://bugs.openjdk.java.net/browse/JDK-8161372</span></span><br><span class="line">        <span class="comment">// It should be removed once the fix is backported to Java 8 or</span></span><br><span class="line">        <span class="comment">// MyBatis drops Java 8 support. See gh-1929</span></span><br><span class="line">        MapperMethodInvoker invoker = methodCache.get(method);</span><br><span class="line">        <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> methodCache.computeIfAbsent(method, m -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.isDefault()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (privateLookupInMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> DefaultMethodInvoker(getMethodHandleJava8(method));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> DefaultMethodInvoker(getMethodHandleJava9(method));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException | InvocationTargetException</span><br><span class="line">                         | NoSuchMethodException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PlainMethodInvoker(<span class="keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException re) &#123;</span><br><span class="line">        Throwable cause = re.getCause();</span><br><span class="line">        <span class="keyword">throw</span> cause == <span class="keyword">null</span> ? re : cause;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>












      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/notes/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/notes/">1</a><span class="page-number current">2</span><a class="page-number" href="/notes/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/notes/page/11/">11</a><a class="extend next" rel="next" href="/notes/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Sinngle</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/notes/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/notes/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/notes/tags/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sinngle</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/notes/lib/anime.min.js"></script>
  <script src="/notes/lib/velocity/velocity.min.js"></script>
  <script src="/notes/lib/velocity/velocity.ui.min.js"></script>

<script src="/notes/js/utils.js"></script>

<script src="/notes/js/motion.js"></script>


<script src="/notes/js/schemes/pisces.js"></script>


<script src="/notes/js/next-boot.js"></script>




  















  

  

</body>
</html>
